{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This is the companion site to Tetrate's Envoy Gateway course, which will be published on Tetrate Academy in November 2024.</p>"},{"location":"#artifacts","title":"Artifacts","text":"<p>Download all yaml artifacts referenced in all scenarios as a single .tgz file here.</p>"},{"location":"basic-auth/","title":"Basic Authentication","text":"<p>Envoy Gateway supports a number of distinct authentication mechanisms, including JWT, OIDC, external authorization, and basic auth.</p> <p>In this exercise, we keep things simple and demonstrate basic auth.</p> <p>Once more, we are dealing with a feature that is outside the current Gateway API specification, and so we use a SecurityPolicy attachment against the route we wish to protect, which in this case is the <code>httpbin</code> route.</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: SecurityPolicy\nmetadata:\n  name: httpbin-basicauth\n  namespace: httpbin\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  basicAuth:\n    users:\n      name: httpbin-users\n</code></pre> <p>The value of the <code>name</code> field on line 13 refers a secret containing an <code>htpasswd</code> file.</p> <ol> <li> <p>Create the htpasswd file:</p> <pre><code>htpasswd -cs .htpasswd eitan\n</code></pre> </li> <li> <p>Create the secret from the generated file:</p> <pre><code>kubectl create secret generic -n httpbin httpbin-users --from-file=.htpasswd\n</code></pre> </li> <li> <p>Apply the security policy:</p> <pre><code>kubectl apply -f basic-auth/auth-config.yaml\n</code></pre> </li> </ol>"},{"location":"basic-auth/#test-it","title":"Test it","text":"<p>Access the application, or:</p> <ol> <li> <p>Request without credentials return a 401 (Unauthorized)</p> <pre><code>curl --insecure --head https://httpbin.example.com/ \\\n  --resolve httpbin.example.com:443:$GATEWAY_IP\n</code></pre> <pre><code>HTTP/2 401\ncontent-length: 58\ncontent-type: text/plain\ndate: Tue, 07 May 2024 23:18:11 GMT\n</code></pre> </li> <li> <p>Authenticated requests succeed:</p> <pre><code>curl --insecure --head --user eitan:correctpassword https://httpbin.example.com/ \\\n  --resolve httpbin.example.com:443:$GATEWAY_IP\n</code></pre> <pre><code>HTTP/2 200\nserver: gunicorn/19.9.0\ndate: Tue, 07 May 2024 23:18:20 GMT\ncontent-type: text/html; charset=utf-8\ncontent-length: 9593\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\n</code></pre> </li> <li> <p>Bad credentials produce a 401 (Forbidden):</p> <pre><code>curl --insecure --head --user eitan:wrongpassword https://httpbin.example.com/ \\\n  --resolve httpbin.example.com:443:$GATEWAY_IP\n</code></pre> <pre><code>HTTP/2 401\ncontent-length: 66\ncontent-type: text/plain\ndate: Tue, 07 May 2024 23:18:23 GMT\n</code></pre> </li> </ol>"},{"location":"basic-auth/#inspect-the-proxy-configuration","title":"Inspect the Proxy configuration","text":"<p>We can look at the Envoy listeners configuration and inspect the HTTP connection manager's filter chain to confirm that the basic auth filter is installed.</p> <pre><code>egctl config envoy-proxy listener -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=infra \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Here is sanitized output for the HTTPS listener:</p> <pre><code>...\nfilterChains:\n- filterChainMatch:\n    serverNames:\n    - httpbin.example.com\n  filters:\n  - name: envoy.filters.network.http_connection_manager\n    typedConfig:\n      httpFilters:\n      - name: envoy.filters.http.basic_auth\n        disabled: true\n        typedConfig:\n          '@type': type.googleapis.com/envoy.extensions.filters.http.basic_auth.v3.BasicAuth\n          users:\n            inlineBytes: W3JlZGFjdGVkXQ==\n      - name: envoy.filters.http.ratelimit\n        ...\n      - name: envoy.filters.http.router\n        ...\n</code></pre> <p>The basic auth filter is configured at the level of the listener, but disabled there. Since the authentication rule is applied at the route level, we need to look at the route.</p> <pre><code>egctl config envoy-proxy route -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=infra \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Here is the salient part of the output:</p> <pre><code>envoy-gateway-system:\n  envoy-infra-eg-eade8e06-5f9f47c8bf-gwh4g:\n    dynamicRouteConfigs:\n    ...\n    - routeConfig:\n        name: infra/eg/https-httpbin\n        virtualHosts:\n        - domains:\n          - httpbin.example.com\n          name: infra/eg/https-httpbin/httpbin_example_com\n          routes:\n          - match:\n              prefix: /\n            name: httproute/httpbin/httpbin/rule/0/match/0/httpbin_example_com\n            route:\n              cluster: httproute/httpbin/httpbin/rule/0\n              rateLimits:\n              ...\n            typedPerFilterConfig:\n              envoy.filters.http.basic_auth:\n                '@type': type.googleapis.com/envoy.extensions.filters.http.basic_auth.v3.BasicAuthPerRoute\n                users:\n                  inlineBytes: W3JlZGFjdGVkXQ==\n</code></pre>"},{"location":"ext-authz/","title":"External Authorization","text":"<p>This scenario demonstrates how Envoy's external authorization filter can be applied to an HttpRoute.</p>"},{"location":"ext-authz/#context","title":"Context","text":"<p>We will use the Ext Authz service sample from the Istio distribution.</p> <p>Deploy the service to the <code>httpbin</code> namespace:</p> <pre><code>kubectl apply -f ext-authz/ext-authz.yaml -n httpbin\n</code></pre>"},{"location":"ext-authz/#the-contract","title":"The contract","text":"<p>The service you just deployed will allow (200) any request bearing the header <code>x-ext-authz: allow</code>.</p> <p>The absence of the header, or the header with a value other than <code>allow</code> will be denied (403).</p>"},{"location":"ext-authz/#instructions","title":"Instructions","text":"<p>Make sure that the <code>httpbin</code> service is deployed, and a simple route is defined from the gateway to the service.</p> <p>Review the following security policy:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: SecurityPolicy\nmetadata:\n  name: ext-authz-policy\n  namespace: httpbin\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  extAuth:\n    http:\n      backendRefs:\n      - group: \"\"\n        kind: Service\n        name: ext-authz\n        port: 8000\n    headersToExtAuth:\n    - x-ext-authz\n</code></pre> <p>Apply the policy:</p> <pre><code>kubectl apply -f ext-authz/security-policy.yaml\n</code></pre> <p>Send a test request:</p> <pre><code>curl -v -H \"x-ext-authz: allow\" http://httpbin.example.com/json --resolve httpbin.example.com:80:$GATEWAY_IP\n</code></pre> <p>The above request should succeed.</p> <p>Absence of the header, or header value that is not \"allow\" will return a 403.</p>"},{"location":"ext-authz/#discussion","title":"Discussion","text":"<p>Above, we chose to deploy the <code>ext-authz</code> service in the same namespace where our route and security policies reside, so the service was resolved relative to that \"local\" namespace.</p> <p>If we had opted to deploy the <code>ext-authz</code> service to another namespace, say the <code>default</code> namespace, not only would we have had to revise the security policy to reference the service in that namespace (add a <code>namespace</code> field to the <code>backendRef</code>), but in addition the owner of the target (<code>default</code>) namespace would have to give us permission to do so via a ReferenceGrant:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: ReferenceGrant\nmetadata:\n  name: allow-access-to-extauthz\n  namespace: default\nspec:\n  from:\n  - group: gateway.envoyproxy.io\n    kind: SecurityPolicy\n    namespace: httpbin\n  to:\n  - group: \"\"\n    kind: Service\n</code></pre> <p>See if you can revise the implementation accordingly.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#deploy-a-workload","title":"Deploy a workload","text":"<pre><code>kubectl apply -f apps/httpbin.yaml\n</code></pre> <p>httpbin is a well-known \"simple HTTP request &amp; response service\" that exposes endpoints useful for testing different types of HTTP requests.</p>"},{"location":"getting-started/#deploy-a-gateway","title":"Deploy a Gateway","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: eg\nspec:\n  gatewayClassName: eg\n  listeners:\n  - name: http\n    protocol: HTTP\n    port: 80\n</code></pre> <pre><code>kubectl apply -f getting-started/gateway-http.yaml\n</code></pre> <p>Wait for the gateway to become available:</p> <pre><code>kubectl wait gtw/eg --for=condition=Programmed\n</code></pre> <p><code>egctl</code> provides a command to display the status of gateways:</p> <pre><code>egctl x status gateway -v\n</code></pre>"},{"location":"getting-started/#test-it","title":"Test it","text":"<pre><code>export GATEWAY_IP=$(kubectl get gtw eg -o jsonpath='{.status.addresses[0].value}')\n</code></pre> <p>Note</p> <p>When using a local k3d cluster, k3d will usually configure the loopback address (127.0.0.1) as the gateway IP address.  In that case, configure your GATEWAY_IP as follows:</p> <pre><code>export GATEWAY_IP=127.0.0.1\n</code></pre> <p>On MacOS, there are projects (for example docker-mac-net-connect) that provide a way to connect to containers running on Docker Desktop.</p> <pre><code>curl -v http://$GATEWAY_IP/\n</code></pre> <pre><code>*   Trying 34.121.222.176:80...\n* Connected to 34.121.222.176 (34.121.222.176) port 80\n&gt; GET / HTTP/1.1\n&gt; Host: 34.121.222.176\n&gt; User-Agent: curl/8.7.1\n&gt; Accept: */*\n&gt;\n* Request completely sent off\n&lt; HTTP/1.1 404 Not Found\n&lt; date: Tue, 07 May 2024 23:39:35 GMT\n&lt; content-length: 0\n&lt;\n* Connection #0 to host 34.121.222.176 left intact\n</code></pre> <p>Why do we get a 404 (Not Found)?</p>"},{"location":"getting-started/#define-an-httproute-to-httpbin","title":"Define an HTTPRoute to <code>httpbin</code>","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin\nspec:\n  hostnames:\n  - httpbin.example.com\n  parentRefs:\n  - name: eg\n  rules:\n  - backendRefs:\n    - name: httpbin\n      port: 8000\n</code></pre> <pre><code>kubectl apply -f getting-started/httpbin-route.yaml\n</code></pre>"},{"location":"getting-started/#verify","title":"Verify","text":"<p>After the DNS entry is created for the hostname specified in the HTTPRoute, try to access the app:</p> <pre><code>curl http://httpbin.example.com/json --resolve httpbin.example.com:80:$GATEWAY_IP\n</code></pre> <p>Note</p> <p>Above, we use <code>curl</code>'s <code>--resolve</code> flag to resolve the host name to the gateway IP address.</p> <p>It's a simple alternative to creating DNS entries that resolve hostnames to public IP addresses, and allows us to work with a purely local environment.</p>"},{"location":"getting-started/#next","title":"Next","text":"<p>In the next section, you will be constructing an ingress configuration that takes into account multiple tenants using a shared gateway.</p> <p>In anticipation of configuring a shared gateway using multiple tenants, delete the gateway, the workload, and the route from the scenario you just completed:</p> <pre><code>kubectl delete httproute httpbin\n</code></pre> <pre><code>kubectl delete gtw eg\n</code></pre> <pre><code>kubectl delete -f apps/httpbin.yaml\n</code></pre>"},{"location":"https/","title":"HTTPS","text":"<p>The objective of this scenario is to serve application traffic over HTTPS.</p>"},{"location":"https/#design-decisions","title":"Design decisions","text":"<ul> <li>All traffic should be over HTTPS</li> <li>All HTTP requests should be automatically redirected to HTTPS</li> <li>App teams should not be able to define routes over HTTP</li> <li>The platform team will manage the configuration of TLS termination for the application teams</li> <li>App teams continue to have the ability to self-service routes against the shared gateway</li> </ul> <p>We decide to use cert-manager to generate and otherwise manage certificates.</p>"},{"location":"https/#deploy-cert-manager","title":"Deploy <code>cert-manager</code>","text":"<pre><code>helm repo add jetstack https://charts.jetstack.io --force-update\nhelm repo update\n</code></pre> <pre><code>helm upgrade --install --create-namespace --namespace cert-manager \\\n  --set crds.enabled=true \\\n  --set \"extraArgs={--enable-gateway-api}\" \\\n  cert-manager jetstack/cert-manager\n</code></pre>"},{"location":"https/#create-a-self-signed-issuer","title":"Create a self-signed issuer","text":"<pre><code>---\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: self-signed\nspec:\n  selfSigned: {}\n</code></pre> <pre><code>kubectl apply -f https/selfsigned-issuer.yaml\n</code></pre>"},{"location":"https/#update-the-gateway-configuration","title":"Update the Gateway configuration","text":"<p>Review the below updated Gateway configuration:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: eg\n  namespace: infra\n  annotations:\n    cert-manager.io/cluster-issuer: self-signed\nspec:\n  gatewayClassName: eg\n  listeners:\n  - name: http\n    protocol: HTTP\n    port: 80\n    allowedRoutes:\n      namespaces:\n        from: Same\n  - name: https-httpbin\n    protocol: HTTPS\n    port: 443\n    hostname: httpbin.example.com\n    tls:\n      mode: Terminate\n      certificateRefs:\n      - name: httpbin-cert\n    allowedRoutes:\n      namespaces:\n        from: Selector\n        selector:\n          matchLabels:\n            self-serve-ingress: \"true\"\n  - name: https-customers\n    protocol: HTTPS\n    port: 443\n    hostname: customers-frontend.example.com\n    tls:\n      mode: Terminate\n      certificateRefs:\n      - name: customers-cert\n    allowedRoutes:\n      namespaces:\n        from: Selector\n        selector:\n          matchLabels:\n            self-serve-ingress: \"true\"\n</code></pre> <p>Note the following:</p> <ul> <li>In addition to the HTTP listener on port 80, we add HTTPS listeners on port 443 for both <code>httpbin</code> and the <code>customers</code> hostnames.</li> <li>The HTTPS listeners are configured to terminate TLS and reference a certificate in Kubernetes secrets:  <code>httpbin-cert</code> for <code>httpbin</code> and <code>customers-cert</code> for the <code>customers</code> app.</li> <li>The <code>allowedRoutes</code> configuration that allows app teams to self-service their own routes is now specified at the HTTPS listener level.</li> <li>Routes can only be attached to the HTTP listener if they're defined in the same namespace as the Gateway resource (<code>infra</code>).</li> <li>The annotation on line eight (8) enlists <code>cert-manager</code>'s certificate issuer to generate the certificates and store them in the specified secrets.</li> </ul> <p>Apply the configuration:</p> <pre><code>kubectl apply -f https/gateway-add-https.yaml\n</code></pre>"},{"location":"https/#test-it","title":"Test it","text":"<p>Access <code>httpbin</code> over TLS:</p> <ul> <li> <p>A verbose HEAD request showing the TLS handshake:</p> <pre><code>curl --insecure -v --head https://httpbin.example.com/ \\\n  --resolve httpbin.example.com:443:$GATEWAY_IP\n</code></pre> </li> <li> <p>A call to the <code>/json</code> endpoint over https:</p> <pre><code>curl --insecure https://httpbin.example.com/json \\\n  --resolve httpbin.example.com:443:$GATEWAY_IP\n</code></pre> </li> </ul>"},{"location":"https/#configure-redirection","title":"Configure redirection","text":"<p>The platform team is the only party with the permission to apply this routing rule, to redirect HTTP requests to HTTPS with a 301 (redirected) response code:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin-redirect-to-https\n  namespace: infra\nspec:\n  hostnames:\n  - \"*.example.com\"\n  parentRefs:\n  - name: eg\n    sectionName: http\n  rules:\n  - filters:\n    - type: RequestRedirect\n      requestRedirect:\n        scheme: https\n        statusCode: 301\n</code></pre> <pre><code>kubectl apply -f https/httpbin-to-https.yaml\n</code></pre> <p>To learn more about HTTPRoute rules and specifically filters, see the relevant section in the Gateway API documentation.</p>"},{"location":"https/#test","title":"Test","text":"<p>Verify that you get a 301 response when curling the http endpoint:</p> <pre><code>curl -v http://httpbin.example.com/ --resolve httpbin.example.com:80:$GATEWAY_IP\n</code></pre> <p>Here is a copy of the captured output:</p> <pre><code>* Host httpbin.example.com:80 was resolved.\n* IPv6: (none)\n* IPv4: 34.121.222.176\n*   Trying 34.121.222.176:80...\n* Connected to httpbin.example.com (34.121.222.176) port 80\n&gt; GET / HTTP/1.1\n&gt; Host: httpbin.example.com\n&gt; User-Agent: curl/8.7.1\n&gt; Accept: */*\n&gt;\n* Request completely sent off\n&lt; HTTP/1.1 301 Moved Permanently\n&lt; location: https://httpbin.example.com:443/\n&lt; date: Tue, 07 May 2024 21:21:19 GMT\n&lt; content-length: 0\n&lt;\n* Connection #0 to host httpbin.example.com left intact\n</code></pre>"},{"location":"https/#summary","title":"Summary","text":"<p>We now have an ingress configuration that functions over HTTPS using a shared gateway that accommodates the needs of both the platform team and multiple application teams.</p>"},{"location":"observability/","title":"Observability","text":"<p>The following content is distilled from the Envoy Gateway docs.</p> <p>The objective is to collect Gateway metrics with Prometheus and expose them through Grafana dashboards.</p>"},{"location":"observability/#generate-a-load","title":"Generate a load","text":"<pre><code>while true; do\n  curl --insecure --head https://httpbin.example.com/json --resolve httpbin.example.com:443:$GATEWAY_IP\n  sleep 0.5\ndone\n</code></pre>"},{"location":"observability/#viewing-proxy-metrics-directly-with-egctl","title":"Viewing proxy metrics directly with <code>egctl</code>","text":"<p>The <code>egctl</code> CLI provides an experimental <code>stats</code> subcommand for displaying metrics exposed by an Envoy proxy instance.</p> <p>We used this command in a previous lab to watch the upstream retries metric (<code>envoy_cluster_upstream_rq_retry</code>).</p> <p>Using labels to identify the proxy we wish to target, we can obtain its metrics with the following command:</p> <pre><code>egctl x stats envoy-proxy \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=infra \\\n  -n envoy-gateway-system\n</code></pre> <p>We can use the <code>--type=clusters</code> option to display metrics that are specific to Envoy clusters (upstream services) defined in its configuration:</p> <pre><code>egctl x stats envoy-proxy \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=infra \\\n  -n envoy-gateway-system \\\n  --type clusters\n</code></pre>"},{"location":"observability/#deploy-observability-tools","title":"Deploy Observability tools","text":"<p>The Envoy Gateway project goes a step further, and provides a helm chart that makes it easy to ingest those metrics into Prometheus, and monitor our proxies through Grafana dashboards.</p> <p>The following command will deploy all necessary observability tools to the <code>monitoring</code> namespace, including prometheus and grafana:</p> <pre><code>helm install eg-addons oci://docker.io/envoyproxy/gateway-addons-helm \\\n  --version v1.1.0 \\\n  --set opentelemetry-collector.enabled=true \\\n  -n monitoring --create-namespace\n</code></pre> <p>Confirm that Prometheus, Grafana, and other observability tools (loki, tempo, fluent-bit) are running in the <code>monitoring</code> namespace.</p>"},{"location":"observability/#monitor-envoy","title":"Monitor Envoy","text":"<p>A LoadBalancer type service is already defined for Grafana in the <code>monitoring</code> namespace.</p> <p>If you're running locally or don't have a public IP address associated with the service, you can use the <code>kubectl port-forward</code> command:</p> <pre><code>kubectl -n monitoring port-forward svc/grafana 3000:80\n</code></pre> <p>Visit localhost:3000 and login to grafana using <code>admin:admin</code>.</p> <ul> <li>The prometheus data source is already configured.</li> <li>Several Envoy monitoring dashboards have already be imported and can be seen in the <code>envoy-gateway</code> folder.</li> </ul> <p>You will find four distinct dashboards:</p> <ul> <li>Envoy Global: monitor Envoy proxies (data plane)</li> <li>Envoy Gateway Global: monitor Envoy Gateway (control plane)</li> <li>Envoy Clusters: Envoy proxy metrics with cluster/service-level granularity (data plane)</li> <li>Resources Monitor: monitor resource utilization of Envoy proxies and Envoy Gateway</li> </ul>"},{"location":"observability/#ad-hoc-query-metrics","title":"Ad-hoc query metrics","text":"<p>A LoadBalancer type service is already defined for Prometheus in the <code>monitoring</code> namespace.</p> <p>If you're running locally or don't have a public IP address associated with the service, you can use the <code>kubectl port-forward</code> command:</p> <pre><code>kubectl -n monitoring port-forward svc/prometheus 9090:80\n</code></pre> <p>Visit localhost:9090 and look for the retry metric from the retries lab:</p> <pre><code>envoy_cluster_upstream_rq_retry{envoy_cluster_name=\"httproute/default/httpbin/rule/0\"}\n</code></pre>"},{"location":"oidc/","title":"OIDC with Okta","text":"<p>We wish to protect the <code>httpbin</code> application with OpenID Connect authentication.</p> <p>Once authentication is established, we demonstrate how to configure authorization policies for routes based on JWT claims from the user's access token.</p> <p>This example uses Okta as the identity provider where we define our users and their level of access to the application.</p>"},{"location":"oidc/#okta-configuration","title":"Okta configuration","text":"<p>You will configure two users, one will be a default user with standard access to the application, the other will be a privileged user with access to additional endpoints in the application.</p>"},{"location":"oidc/#configure-groups","title":"Configure Groups","text":"<p>Create a group named admin.</p> <p>In Okta:</p> <ul> <li>Navigate to Directory and then to Groups.</li> <li>Click the button Add group.</li> <li>Enter the group name.</li> </ul>"},{"location":"oidc/#configure-users","title":"Configure Users","text":"<p>Create a user with username johndoe@example.com and another with username zeboss@example.com.</p> <p>In Okta:</p> <ul> <li>Navigate to Directory and then to People.</li> <li>Click the button Add person.</li> <li>Enter the details:  user type (User), first and last names, the username (above email address).</li> <li>Check I will set the password.</li> <li>Enter a password.</li> <li>Uncheck User must change password on first login.</li> <li>For the zeboss user, also associate them to the group admin via the Groups field.</li> <li>Click Save.</li> </ul>"},{"location":"oidc/#configure-the-application","title":"Configure the Application","text":"<p>The following instructions are for the hostname <code>httpbin.esuez.org</code>.</p> <p>Edit this value for your specific domain.</p> <p>In Okta:</p> <ul> <li>Navigate to Applications and then to Application.</li> <li>Click the button Create App Integration.</li> <li>Select OIDC as the sign-in method, and Web Application for the application type, and click Next.</li> <li>For App integration name, enter <code>httpbin.esuez.org</code>.</li> <li>Specify <code>https://httpbin.esuez.org/oauth2/callback</code> for the Sign-in redirect URIs field.</li> <li>Enter <code>https://httpbin.esuez.org/logout</code> for the Sign-out redirect URIs field.</li> <li>Click Save.</li> </ul> <p>Edit the application as follows:</p> <ul> <li>Select the tab named Assignments.</li> <li>Click the Assign button.</li> <li>Select Assign to People and assign both users to the application.</li> <li>Select Assign to Groups and assign the admin group to the application.</li> </ul> <p>In the General tab, make note of the client id and client secret. You will need both to configure the environment variables CLIENT_ID and CLIENT_SECRET.</p>"},{"location":"oidc/#configure-the-authorization-server","title":"Configure the Authorization Server","text":"<p>In Okta:</p> <ul> <li>Navigate to Security and then to API.</li> <li>Under Authorization Servers select the existing default authorization server.</li> <li>Make note of the issuer URL to set the ISSUER environment variable.</li> <li>Select the Claims tab.</li> <li>Click the button Add Claim.</li> <li>Set the claim name to access.</li> <li>Keep the defaults: include in token type \"Access Token\", and value type of \"Expression\".</li> <li>For the expression value, enter:  <code>(user == null) ? \"default\" : user.isMemberOfGroupName(\"admin\") ? \"privileged\" : \"default\"</code></li> <li>Click Create.</li> </ul> <p>The above expression translates admin group membership to the value \"privileged\"; absence of membership results in the value \"default.\"</p>"},{"location":"oidc/#test-the-token","title":"Test the token","text":"<ul> <li>Select the tab Token Preview</li> <li>Select the httpbin app integration, the grant type of authorization code, one of the two users, the the scope named openid</li> <li>Select Preview Token</li> <li>Select the tab named token (that would be the access token)</li> <li>Verify that the payload has a claim named access with value of privileged for the admin user and default for the other user.</li> </ul>"},{"location":"oidc/#configuring-authentication","title":"Configuring Authentication","text":"<p>Before proceeding, configure your issuer URL, client id, and client secret.</p> <p>For example:</p> <pre><code>export ISSUER=\"https://dev-*****.okta.com/oauth2/default\"\nexport CLIENT_ID=\"...\"\nexport CLIENT_SECRET=\"*****\"\n</code></pre>"},{"location":"oidc/#kubernetes-secret","title":"Kubernetes secret","text":"<p>Create a Kubernetes secret for the client secret:</p> <pre><code>kubectl create secret generic httpbin-client-secret \\\n  --from-literal=client-secret=$CLIENT_SECRET\n</code></pre>"},{"location":"oidc/#security-policy","title":"Security policy","text":"<p>Review the following security policy specification:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: SecurityPolicy\nmetadata:\n  name: httpbin-security-policy\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  oidc:\n    provider:\n      issuer: \"$ISSUER\"\n    clientID: \"$CLIENT_ID\"\n    clientSecret:\n      name: httpbin-client-secret\n    redirectURL: \"https://httpbin.esuez.org/oauth2/callback\"\n    logoutPath: \"/logout\"\n    forwardAccessToken: true\n</code></pre> <p>We are basically configuring OIDC authentication for the route for the httpbin application.</p> <p>Apply the policy, with variable substitution:</p> <pre><code>envsubst &lt; oidc/oidc-policy.yaml | kubectl apply -f -\n</code></pre>"},{"location":"oidc/#test-it","title":"Test it","text":"<ol> <li>Visit the httpbin route.     You will be redirected to your identity provider.</li> <li>Sign in.     You will be redirected back to the target application.</li> </ol>"},{"location":"oidc/#authorization","title":"Authorization","text":"<p>Review the following augmented security policy specification:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: SecurityPolicy\nmetadata:\n  name: httpbin-security-policy\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  oidc:\n    provider:\n      issuer: \"$ISSUER\"\n    clientID: \"$CLIENT_ID\"\n    clientSecret:\n      name: httpbin-client-secret\n    redirectURL: \"https://httpbin.esuez.org/oauth2/callback\"\n    logoutPath: \"/logout\"\n    forwardAccessToken: true\n  jwt:\n    providers:\n    - name: okta\n      issuer: \"$ISSUER\"\n      recomputeRoute: true\n      claimToHeaders:\n      - claim: sub\n        header: x-sub\n      - claim: access\n        header: x-access\n      remoteJWKS:\n        uri: \"$ISSUER/v1/keys\"\n</code></pre> <p>We are adding a JWT provider that will populate the header <code>x-access</code> with the value from the <code>access</code> claim (default or privileged).</p> <p>Apply the policy, with variable substitution:</p> <pre><code>envsubst &lt; oidc/security-policy.yaml | kubectl apply -f -\n</code></pre> <p>Next, expose the \"admin\" routes only to privileged users:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin\nspec:\n  hostnames:\n  - httpbin.esuez.org\n  parentRefs:\n  - name: eg\n    sectionName: https\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: /headers\n    - path:\n        type: Exact\n        value: /oauth2/callback\n    - path:\n        type: Exact\n        value: /logout\n    backendRefs:\n    - name: httpbin\n      port: 8000\n  - matches:\n    - path:\n        type: PathPrefix\n        value: /\n      headers:\n      - name: x-access\n        value: \"privileged\"\n    backendRefs:\n    - name: httpbin\n      port: 8000\n  - backendRefs:\n    - name: invalid-backend\n      port: 8080\n</code></pre> <p>Above:</p> <ul> <li>We give access to the exact endpoint (path) <code>/headers</code> to all authenticated users.</li> <li>For any other path (path prefix of /), we match only if the header <code>x-access</code> is <code>privileged</code>.</li> </ul> <p>Other than the <code>/headers</code> (and oauth) endpoints, non-privileged users will not have routes to any of the other endpoints of the <code>httpbin</code> application.</p> <p>Apply the claim-based routing policy:</p> <pre><code>kubectl apply -f oidc/authz-route.yaml\n</code></pre> <p>To test the policy:</p> <ul> <li>Sign in as a non-privileged user and verify that you can access the <code>/headers</code> endpoint but no other <code>httpbin</code> application endpoints.</li> <li>Sign in as a privileged user and verify that this user has access to all of the <code>httpbin</code> app endpoints.</li> </ul>"},{"location":"oidc/#references","title":"References","text":"<ul> <li>Envoy Gateway OIDC Authentication Task</li> <li>JWT claims-based routing</li> </ul>"},{"location":"policy-attachments/","title":"Policy attachments","text":"<p>Retries are an example of how EG extends the Kubernetes Gateway API using Policy Attachments.</p> <p>To understand policy attachments, we begin with an example of a feature that is part of the Kubernetes Gateway API:  timeouts, and then turn our attention to retries.</p>"},{"location":"policy-attachments/#timeouts","title":"Timeouts","text":"<p>The Kubernetes Gateway API supports configuring of timeouts.</p> <p>We can specify a total request timeout on the <code>httpbin</code> route of one second, as follows:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin\n  namespace: httpbin\nspec:\n  hostnames:\n  - httpbin.example.com\n  parentRefs:\n  - name: eg\n    namespace: infra\n  rules:\n  - backendRefs:\n    - name: httpbin\n      port: 8000\n    timeouts:\n      request: 1s\n</code></pre> <p>An HTTPS request to the <code>httpbin</code> application will continue to function:</p> <pre><code>curl --insecure https://httpbin.example.com/json \\\n  --resolve httpbin.example.com:443:$GATEWAY_IP\n</code></pre> <p>On the other hand, targeting an endpoint with a delay of two (2) seconds results in a request timeout (504):</p> <pre><code>curl --insecure https://httpbin.example.com/delay/2 \\\n  --resolve httpbin.example.com:443:$GATEWAY_IP\n</code></pre> <pre><code>upstream request timeout\n</code></pre> <p>Configuring timeouts was simple an easy.</p> <p>Envoy is a proxy with more features than the Kubernetes Gateway API codifies.  The API however does provide guidance on how to formally extend its API via policy attachments.</p> <p>Let us look at how Envoy Gateway utilizes policy attachments to expose other features of the Envoy proxy.</p>"},{"location":"policy-attachments/#review-gateway-related-crds","title":"Review Gateway-related CRDs","text":"<p>Inspect the gateway-related CRDs defined in your cluster:</p> <pre><code>kubectl api-resources | grep gateway\n</code></pre> <p>Here is a slightly sanitized copy of the captured output:</p> <pre><code>gateway.envoyproxy.io/v1alpha1       Backend\ngateway.envoyproxy.io/v1alpha1       BackendTrafficPolicy\ngateway.envoyproxy.io/v1alpha1       ClientTrafficPolicy\ngateway.envoyproxy.io/v1alpha1       EnvoyExtensionPolicy\ngateway.envoyproxy.io/v1alpha1       EnvoyPatchPolicy\ngateway.envoyproxy.io/v1alpha1       EnvoyProxy\ngateway.envoyproxy.io/v1alpha1       SecurityPolicy\ngateway.networking.k8s.io/v1alpha2   BackendLBPolicy\ngateway.networking.k8s.io/v1alpha3   BackendTLSPolicy\ngateway.networking.k8s.io/v1         GatewayClass\ngateway.networking.k8s.io/v1         Gateway\ngateway.networking.k8s.io/v1         GRPCRoute\ngateway.networking.k8s.io/v1         HTTPRoute\ngateway.networking.k8s.io/v1beta1    ReferenceGrant\ngateway.networking.k8s.io/v1alpha2   TCPRoute\ngateway.networking.k8s.io/v1alpha2   TLSRoute\ngateway.networking.k8s.io/v1alpha2   UDPRoute\n</code></pre> <p>Note the standard Kubernetes Gateway API CRDs as well as additional ones defined by the Envoy Gateway project.</p>"},{"location":"policy-attachments/#use-backendtrafficpolicy-to-configure-retries","title":"Use BackendTrafficPolicy to configure retries","text":"<pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: BackendTrafficPolicy\nmetadata:\n  name: httpbin-traffic-policy\n  namespace: httpbin\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  retry:\n    numRetries: 5\n    perRetry:\n      backOff:\n        baseInterval: 100ms\n        maxInterval: 10s\n      timeout: 250ms\n    retryOn:\n      httpStatusCodes:\n      - 500\n      triggers:\n      - connect-failure\n      - retriable-status-codes\n</code></pre> <pre><code>kubectl apply -f policy-attachments/httpbin-policy.yaml\n</code></pre>"},{"location":"policy-attachments/#verify-review-the-proxy-configuration","title":"Verify: Review the proxy configuration","text":"<pre><code>egctl config envoy-proxy route -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=infra \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Confirm that the routing configuration has been updated with the retry rule.</p> <p>Here is a sanitized copy of the captured output:</p> <pre><code>envoy-gateway-system:\n  envoy-infra-eg-eade8e06-5f9f47c8bf-gwh4g:\n    dynamicRouteConfigs:\n    ...\n    - routeConfig:\n        name: infra/eg/https-httpbin\n        virtualHosts:\n        - domains:\n          - httpbin.example.com\n          name: infra/eg/https-httpbin/httpbin_example_com\n          routes:\n          - match:\n              prefix: /\n            name: httproute/httpbin/httpbin/rule/0/match/0/httpbin_example_com\n            route:\n              cluster: httproute/httpbin/httpbin/rule/0\n              retryPolicy:\n                hostSelectionRetryMaxAttempts: \"5\"\n                numRetries: 5\n                perTryTimeout: 0.250s\n                retriableStatusCodes:\n                - 500\n                retryBackOff:\n                  baseInterval: 0.100s\n                  maxInterval: 10s\n                retryHostPredicate:\n                - name: envoy.retry_host_predicates.previous_hosts\n                retryOn: connect-failure,retriable-status-codes\n</code></pre>"},{"location":"policy-attachments/#verify-review-the-proxys-stats","title":"Verify:  Review the proxy's \"stats\"","text":"<p>Specifically, the <code>envoy_cluster_upstream_rq_retry</code> metric:</p> <pre><code>watch 'egctl x stats envoy-proxy -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=infra \\\n  | grep \"envoy_cluster_upstream_rq_retry{envoy_cluster_name=\\\"httproute/httpbin/httpbin/rule/0\\\"}\"'\n</code></pre> <p>In another terminal, call a failing endpoint:</p> <pre><code>curl --insecure --head https://httpbin.example.com/status/500 \\\n  --resolve httpbin.example.com:443:$GATEWAY_IP\n</code></pre> <p>Another convenient way to get at the stats exposed by the Envoy proxy is through the Envoy admin interface:</p> <pre><code>egctl x dashboard envoy-proxy -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=infra\n</code></pre> <p>Click on the <code>stats</code> endpoint and look for metrics with \"retry\" in their name.</p>"},{"location":"policy-attachments/#verify-tail-the-gateway-logs","title":"Verify: Tail the gateway logs","text":"<pre><code>kubectl logs --tail 1 -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=infra | jq\n</code></pre> <p>Below is a copy of the prettified JSON log line:</p> <pre><code>{\n  \"start_time\": \"2024-08-07T23:32:00.874Z\",\n  \"method\": \"HEAD\",\n  \"x-envoy-origin-path\": \"/status/500\",\n  \"protocol\": \"HTTP/2\",\n  \"response_code\": \"500\",\n  \"response_flags\": \"URX\",\n  \"response_code_details\": \"via_upstream\",\n  \"connection_termination_details\": \"-\",\n  \"upstream_transport_failure_reason\": \"-\",\n  \"bytes_received\": \"0\",\n  \"bytes_sent\": \"0\",\n  \"duration\": \"787\",\n  \"x-envoy-upstream-service-time\": \"-\",\n  \"x-forwarded-for\": \"172.19.0.1\",\n  \"user-agent\": \"curl/8.9.1\",\n  \"x-request-id\": \"fff65b4e-5a41-41fb-8a3e-fc9f33121059\",\n  \":authority\": \"httpbin.example.com\",\n  \"upstream_host\": \"10.42.0.12:8080\",\n  \"upstream_cluster\": \"httproute/httpbin/httpbin/rule/0\",\n  \"upstream_local_address\": \"10.42.0.22:42978\",\n  \"downstream_local_address\": \"10.42.0.22:10443\",\n  \"downstream_remote_address\": \"172.19.0.1:60922\",\n  \"requested_server_name\": \"httpbin.example.com\",\n  \"route_name\": \"httproute/httpbin/httpbin/rule/0/match/0/httpbin_example_com\"\n}\n</code></pre> <p>Note the Envoy response flag is URX: UpstreamRetryLimitExceeded.</p>"},{"location":"policy-attachments/#summary","title":"Summary","text":"<p>To configure retries, we had to resort to using a BackingTrafficPolicy, an extension to the Gateway API. In contrast, compare with timeouts, which are configured directly on the HTTPRoute resource, since timeouts are a part of the Kubernetes Gateway API specification.</p>"},{"location":"ratelimit/","title":"Rate limiting","text":"<p>Similar to retries, rate limiting is not part of the Kubernetes Gateway API specification, and is configured through Envoy Gateway's BackendTrafficPolicy resource.</p> <p>The rate limit is associated with the HTTPRoute you wish to limit.</p>"},{"location":"ratelimit/#configuring-eg-for-rate-limiting","title":"Configuring EG for rate limiting","text":"<p>EG supports Envoy's Global Rate limiting feature, which depends on a backing Redis instance to maintain shared state.</p> <p>Before we can begin to exercise rate limiting, we need to deploy a Redis instance and configure EG with the Redis url.</p> <p>Detailed instructions are available in the EG docs.</p> <p>Follow those instructions to:</p> <ol> <li>Deploy Redis</li> <li>Update the <code>envoy-gateway-config</code> ConfigMap to specify the Redis backend url</li> <li>Restart the <code>envoy-gateway</code> deployment</li> </ol>"},{"location":"ratelimit/#simple-example","title":"Simple example","text":"<p>Configure access to <code>httpbin</code> to be limited to three requests per minute:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: BackendTrafficPolicy \nmetadata:\n  name: httpbin-traffic-policy\n  namespace: httpbin\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  rateLimit:\n    type: Global\n    global:\n      rules:\n      - limit:\n          requests: 3\n          unit: Minute\n</code></pre> <pre><code>kubectl apply -f ratelimit/simple.yaml\n</code></pre>"},{"location":"ratelimit/#test-it","title":"Test it","text":"<p>Send four requests in succession, the fourth should be rate-limited:</p> <pre><code>for i in {1..4}; do\n  curl --insecure --head https://httpbin.example.com/ --resolve httpbin.example.com:443:$GATEWAY_IP\ndone\n</code></pre> <p>Here is the captured output:</p> <pre><code>HTTP/2 200\nserver: gunicorn/19.9.0\ndate: Tue, 07 May 2024 22:33:12 GMT\ncontent-type: text/html; charset=utf-8\ncontent-length: 9593\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\nx-ratelimit-limit: 3, 3;w=60\nx-ratelimit-remaining: 2\nx-ratelimit-reset: 48\n\nHTTP/2 200\nserver: gunicorn/19.9.0\ndate: Tue, 07 May 2024 22:33:12 GMT\ncontent-type: text/html; charset=utf-8\ncontent-length: 9593\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\nx-ratelimit-limit: 3, 3;w=60\nx-ratelimit-remaining: 1\nx-ratelimit-reset: 48\n\nHTTP/2 200\nserver: gunicorn/19.9.0\ndate: Tue, 07 May 2024 22:33:12 GMT\ncontent-type: text/html; charset=utf-8\ncontent-length: 9593\naccess-control-allow-origin: *\naccess-control-allow-credentials: true\nx-ratelimit-limit: 3, 3;w=60\nx-ratelimit-remaining: 0\nx-ratelimit-reset: 48\n\nHTTP/2 429\nx-envoy-ratelimited: true\nx-ratelimit-limit: 3, 3;w=60\nx-ratelimit-remaining: 0\nx-ratelimit-reset: 48\ndate: Tue, 07 May 2024 22:33:12 GMT\n</code></pre> <p>Above, note:</p> <ul> <li>the 429 (too many requests) response code on the fourth request, and</li> <li>the <code>x-ratelimit-*</code> headers that inform us of the limit, the number of requests remaining, and the amount of time (in seconds) until the corresponding counter is reset.</li> </ul>"},{"location":"ratelimit/#verify-tail-the-gateway-logs","title":"Verify: Tail the gateway logs","text":"<pre><code>kubectl logs --tail 1 -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=infra | jq\n</code></pre> <p>Below is a copy of the prettified JSON log line:</p> <pre><code>{\n  \"start_time\": \"2024-08-08T00:21:14.929Z\",\n  \"method\": \"HEAD\",\n  \"x-envoy-origin-path\": \"/\",\n  \"protocol\": \"HTTP/2\",\n  \"response_code\": \"429\",\n  \"response_flags\": \"RL\",\n  \"response_code_details\": \"request_rate_limited\",\n  \"connection_termination_details\": \"-\",\n  \"upstream_transport_failure_reason\": \"-\",\n  \"bytes_received\": \"0\",\n  \"bytes_sent\": \"0\",\n  \"duration\": \"1\",\n  \"x-envoy-upstream-service-time\": \"-\",\n  \"x-forwarded-for\": \"172.19.0.1\",\n  \"user-agent\": \"curl/8.9.1\",\n  \"x-request-id\": \"04186347-7203-41d0-8b56-965bc32ef60a\",\n  \":authority\": \"httpbin.example.com\",\n  \"upstream_host\": \"-\",\n  \"upstream_cluster\": \"httproute/httpbin/httpbin/rule/0\",\n  \"upstream_local_address\": \"-\",\n  \"downstream_local_address\": \"10.42.0.22:10443\",\n  \"downstream_remote_address\": \"172.19.0.1:62217\",\n  \"requested_server_name\": \"httpbin.example.com\",\n  \"route_name\": \"httproute/httpbin/httpbin/rule/0/match/0/httpbin_example_com\"\n}\n</code></pre> <p>Note the Envoy response flag is RL: RateLimited.</p>"},{"location":"ratelimit/#rate-limit-distinct-users","title":"Rate limit distinct users","text":"<p>It is more common for individual users to each have their own limit.</p> <p>The below example adds a rate limit selection condition to distinguish between users by http header name of <code>x-user-id</code>:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: BackendTrafficPolicy \nmetadata:\n  name: httpbin-traffic-policy\n  namespace: httpbin\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  rateLimit:\n    type: Global\n    global:\n      rules:\n      - clientSelectors:\n        - headers:\n          - type: Distinct\n            name: x-user-id\n        limit:\n          requests: 3\n          unit: Minute\n</code></pre> <pre><code>kubectl apply -f ratelimit/distinct-users.yaml\n</code></pre>"},{"location":"ratelimit/#test-it_1","title":"Test it","text":"<p>Sending multiple requests for the same user in succession will produce a result similar to the above simple example:</p> <pre><code>for i in {1..4}; do\n  curl --insecure --head -H \"x-user-id: eitan\" https://httpbin.example.com/ \\\n    --resolve httpbin.example.com:443:$GATEWAY_IP\ndone\n</code></pre> <p>Following that up with another set of requests from a different user demonstrates that each user has their own, separate rate limiting counter:</p> <pre><code>for i in {1..4}; do\n  curl --insecure --head -H \"x-user-id: johndoe\" https://httpbin.example.com/ \\\n    --resolve httpbin.example.com:443:$GATEWAY_IP\ndone\n</code></pre> <p>The curious may wish to inspect the translated configuration at the Envoy proxy:</p> <pre><code>egctl config envoy-proxy route -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=infra \\\n  -o yaml | bat -l yaml\n</code></pre> <p>Here is a sanitized copy of the captured output:</p> <pre><code>envoy-gateway-system:\n  envoy-infra-eg-eade8e06-5f9f47c8bf-gwh4g:\n    dynamicRouteConfigs:\n    - ...\n    - routeConfig:\n        name: infra/eg/https-httpbin\n        virtualHosts:\n        - domains:\n          - httpbin.example.com\n          name: infra/eg/https-httpbin/httpbin_example_com\n          routes:\n          - match:\n              prefix: /\n            name: httproute/httpbin/httpbin/rule/0/match/0/httpbin_example_com\n            route:\n              cluster: httproute/httpbin/httpbin/rule/0\n              rateLimits:\n              - actions:\n                - genericKey:\n                    descriptorKey: httproute/httpbin/httpbin/rule/0/match/0/httpbin_example_com\n                    descriptorValue: httproute/httpbin/httpbin/rule/0/match/0/httpbin_example_com\n                - requestHeaders:\n                    descriptorKey: rule-0-match-0\n                    headerName: x-user-id\n</code></pre>"},{"location":"setup/","title":"Installation &amp; setup","text":""},{"location":"setup/#provision-a-cluster","title":"Provision a cluster","text":"<pre><code>#!/bin/sh\n\nk3d cluster create my-k8s-cluster \\\n  --k3s-arg \"--disable=traefik@server:0\" \\\n  --port 80:80@loadbalancer \\\n  --port 443:443@loadbalancer\n</code></pre> <pre><code>./setup/make-local-k3d-cluster\n</code></pre> <p>About k3d.</p>"},{"location":"setup/#install-eg","title":"Install EG","text":"<pre><code>helm install eg oci://docker.io/envoyproxy/gateway-helm \\\n  --version v1.1.0 \\\n  -n envoy-gateway-system --create-namespace\n</code></pre>"},{"location":"setup/#define-a-gatewayclass","title":"Define a GatewayClass:","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: eg\nspec:\n  controllerName: gateway.envoyproxy.io/gatewayclass-controller\n</code></pre> <pre><code>kubectl apply -f setup/gateway-class.yaml\n</code></pre>"},{"location":"setup/#install-the-egctl-cli","title":"Install the <code>egctl</code> CLI","text":"<p>Envoy Gateway comes with its own command-line tool, <code>egctl</code>, which provides a variety of helpful subcommands that we explore in subsequent lessons.</p> <p><code>egctl</code> can be installed in different ways:</p> <ul> <li>From binaries (published with each release for different platforms).</li> <li>Via an install script.</li> <li>On MacOS, with the homebrew package manager.</li> </ul> <p>Installation instructions are available in the Envoy Gateway documentation.</p>"},{"location":"shared-gw/","title":"Shared Gateways","text":"<p>One important aspect of the Kubernetes Gateway API is its ability to accommodate multiple personas.  Cluster operators typically provision and control gateways, but application teams want the ability self-service routes to their backend applications.</p> <p>In this scenario, we explore two teams each deploying distinct applications to separate namespaces who have the ability to specify their own routes against a shared gateway managed by the operations team.</p>"},{"location":"shared-gw/#design-and-conventions","title":"Design and conventions","text":"<p>The platform team decides to deploy their gateway to the <code>infra</code> namespace, and defines a convention whereby the ability to attach routes to the gateway can be given to application teams when their application namespaces are labeled with <code>self-serve-ingress=true</code>.</p>"},{"location":"shared-gw/#deploy-the-gateway","title":"Deploy the Gateway","text":"<p>Create the namespace:</p> <pre><code>kubectl create ns infra\n</code></pre> <p>Provision the gateway:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: eg\n  namespace: infra\nspec:\n  gatewayClassName: eg\n  listeners:\n  - name: http\n    protocol: HTTP\n    port: 80\n    allowedRoutes:\n      namespaces:\n        from: Selector\n        selector:\n          matchLabels:\n            self-serve-ingress: \"true\"\n</code></pre> <p>Above, note the <code>allowedRoutes</code> section which allows the attachment of routes from namespaces with the corresponding label.</p> <pre><code>kubectl apply -f shared-gw/gateway-http.yaml\n</code></pre> <p>Wait for the gateway to become available:</p> <pre><code>kubectl wait gtw/eg -n infra --for=condition=Programmed\n</code></pre>"},{"location":"shared-gw/#capture-the-gateway-ip-address","title":"Capture the Gateway IP address","text":"<pre><code>export GATEWAY_IP=$(kubectl get gtw eg -n infra -o jsonpath='{.status.addresses[0].value}')\n</code></pre>"},{"location":"shared-gw/#deploy-the-workloads","title":"Deploy the workloads","text":""},{"location":"shared-gw/#the-httpbin-app","title":"The <code>httpbin</code> app","text":"<p>First, create and label the namespace (we assume RBAC is in place to allow only operators to do this):</p> <pre><code>kubectl create ns httpbin\n</code></pre> <pre><code>kubectl label ns httpbin self-serve-ingress=\"true\"\n</code></pre> <p>Next, deploy the application:</p> <pre><code>kubectl apply -f apps/httpbin.yaml -n httpbin\n</code></pre>"},{"location":"shared-gw/#the-customers-app","title":"The <code>customers</code> app","text":"<p>Create the <code>customers</code> namespace:</p> <pre><code>kubectl create ns customers\n</code></pre> <pre><code>kubectl label ns customers self-serve-ingress=\"true\"\n</code></pre> <p>This app consists of two separate deployments:  the <code>customers</code> service and the <code>web-frontend</code>:</p> <pre><code>kubectl apply -f apps/customers.yaml -n customers\n</code></pre> <pre><code>kubectl apply -f apps/web-frontend.yaml -n customers\n</code></pre>"},{"location":"shared-gw/#configure-the-routes","title":"Configure the routes","text":"<pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: httpbin\n  namespace: httpbin\nspec:\n  hostnames:\n  - httpbin.example.com\n  parentRefs:\n  - name: eg\n    namespace: infra\n  rules:\n  - backendRefs:\n    - name: httpbin\n      port: 8000\n</code></pre> <pre><code>kubectl apply -f shared-gw/httpbin-route.yaml\n</code></pre> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: web-frontend\n  namespace: customers\nspec:\n  hostnames:\n  - customers-frontend.example.com\n  parentRefs:\n  - name: eg\n    namespace: infra\n  rules:\n  - backendRefs:\n    - name: web-frontend\n      port: 80\n</code></pre> <pre><code>kubectl apply -f shared-gw/web-frontend-route.yaml\n</code></pre>"},{"location":"shared-gw/#inspect-route-configuration","title":"Inspect route configuration","text":"<p>Review the <code>status</code> section of the shared gateway (named <code>eg</code>):</p> <pre><code>kubectl get -n infra gtw eg -o yaml\n</code></pre> <p>Under <code>listeners</code>, verify that the number of attached routes is two (2).</p> <p>Next, use <code>egctl</code> to inspect the <code>route</code> section of the Envoy configuration:</p> <pre><code>egctl config envoy-proxy route -n envoy-gateway-system \\\n  -l gateway.envoyproxy.io/owning-gateway-name=eg \\\n  -l gateway.envoyproxy.io/owning-gateway-namespace=infra \\\n  -o yaml\n</code></pre> <p>Here is a slightly sanitized copy of the captured output:</p> <pre><code>envoy-gateway-system:\n  envoy-infra-eg-eade8e06-84c7dd49d-rwdpk:\n    dynamicRouteConfigs:\n    - routeConfig:\n        name: infra/eg/http\n        virtualHosts:\n        - domains:\n          - httpbin.example.com\n          name: infra/eg/http/httpbin_example_com\n          routes:\n          - match:\n              prefix: /\n            name: httproute/httpbin/httpbin/rule/0/match/0/httpbin_example_com\n            route:\n              cluster: httproute/httpbin/httpbin/rule/0\n        - domains:\n          - customers-frontend.example.com\n          name: infra/eg/http/customers-frontend_example_com\n          routes:\n          - match:\n              prefix: /\n            name: httproute/customers/web-frontend/rule/0/match/0/customers-frontend_example_com\n            route:\n              cluster: httproute/customers/web-frontend/rule/0\n</code></pre>"},{"location":"shared-gw/#verify","title":"Verify","text":"<p>Verify that the routes are reachable:</p> <pre><code>curl http://httpbin.example.com/json --resolve httpbin.example.com:80:$GATEWAY_IP\n</code></pre> <pre><code>curl http://customers-frontend.example.com/ --resolve customers-frontend.example.com:80:$GATEWAY_IP\n</code></pre>"},{"location":"shared-gw/#summary","title":"Summary","text":"<p>With the Kubernetes Gateway API, have can achieve a separation of concerns, where the platform team can manage a shared gateway, while at the same time application teams can (with the permission of the platform team) define the routes for their applications.</p>"},{"location":"takeaways/","title":"Takeaways","text":"<ul> <li> <p>Envoy Gateway has come a long way.</p> <p>When Matt Klein announced a collaboration between multiple vendors (Tetrate, Ambassador labs, VMware..) to create an open source foundation for Envoy-based gateway solutions, the project was just getting started.</p> </li> <li> <p>EG recently reached the v1.1.0 milestone and is now fully conformant implementation of the Kubernetes Gateway API.</p> </li> <li> <p>EG achieves its objective of unlocking the capabilities of envoyproxy, and making it easy to deploy and configure in a cloud-native environment.</p> </li> <li> <p>There's a lot of goodness to unpack.</p> <p>We scratched the surface exploring only a few example scenarios. The Envoy Gateway tasks section provides recipes for dozens of traffic management and security scenarios.</p> </li> <li> <p>This was only an introduction to Envoy Gateway.</p> <p>Besides the various routing and security configuration scenarios, it's important to explore other facets of EG, including operations and observability.</p> </li> </ul>"},{"location":"traffic-split/","title":"Traffic Splitting","text":"<p>This scenario demonstrates traffic splitting:  how the <code>weight</code> field in an HttpRoute can be used to specify the distribution of traffic between two backend references, two services.</p>"},{"location":"traffic-split/#context","title":"Context","text":"<p>The <code>customers</code> service should already be deployed in the default namespace (see Shared Gateway).</p>"},{"location":"traffic-split/#instructions","title":"Instructions","text":"<ol> <li> <p>Deploy <code>customers-v2</code> backing deployment:</p> <pre><code>---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: customers-v2\n  labels:\n    app: customers\n    version: v2\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: customers\n      version: v2\n  template:\n    metadata:\n      labels:\n        app: customers\n        version: v2\n    spec:\n      serviceAccountName: customers\n      containers:\n      - image: gcr.io/tetratelabs/customers:2.0.0\n        imagePullPolicy: Always\n        name: svc\n        ports:\n        - containerPort: 3000\n</code></pre> <pre><code>kubectl apply -f traffic-split/customers-v2.yaml\n</code></pre> </li> <li> <p>Define services for each v1 and v2 subsets:</p> <pre><code>---\napiVersion: v1\nkind: Service\nmetadata:\n  name: customers-v1\nspec:\n  selector:\n    app: customers\n    version: v1\n  ports:\n  - port: 80\n    name: http\n    targetPort: 3000\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: customers-v2\nspec:\n  selector:\n    app: customers\n    version: v2\n  ports:\n  - port: 80\n    name: http\n    targetPort: 3000\n</code></pre> <pre><code>kubectl apply -f traffic-split/customers-subsets.yaml\n</code></pre> </li> <li> <p>Define an HttpRoute that splits traffic 80/20 between v1 and v2:</p> <pre><code>---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: customers\nspec:\n  hostnames:\n  - customers.example.com\n  parentRefs:\n  - name: eg\n  rules:\n  - backendRefs:\n    - name: customers-v1\n      port: 80\n      weight: 80\n    - name: customers-v2\n      port: 80\n      weight: 20\n</code></pre> <pre><code>kubectl apply -f traffic-split/customers-route.yaml\n</code></pre> </li> </ol>"},{"location":"traffic-split/#test-it","title":"Test it","text":"<p>Send a number of test request to the <code>customers</code> route:</p> <pre><code>for i in {1..10}; do\n  curl http://customers.example.com/ --resolve customers.example.com:80:$GATEWAY_IP\ndone\n</code></pre> <p>About 80% of requests should go to v1.</p> <p>Responses from the <code>v2</code> service can be distinguished from <code>v1</code> by their payload:  v2 returns customer names and cities, whereas v1 returns only customer names.</p>"},{"location":"wasm/","title":"WebAssembly","text":"<p>In this scenario we demonstrate how to apply a wasm extension to an HttpRoute.</p> <p>You will apply an extension policy that references a simple, pre-built wasm plugin to the HttpRoute for the <code>httpbin</code> sample application.</p> <p>The basic logic of the plugin is to inject arbitrary, configurable headers into HTTP responses on the associated route.</p>"},{"location":"wasm/#context","title":"Context","text":"<p><code>httpbin</code> is already deployed, along with a gateway (configured for HTTP), and a route (for hostname <code>httpbin.example.com</code>), matching the configuration from Getting started.</p>"},{"location":"wasm/#instructions","title":"Instructions","text":"<ol> <li> <p>Send a test request to the <code>httpbin</code> route:</p> <pre><code> curl -v http://httpbin.example.com/json --resolve httpbin.example.com:80:$GATEWAY_IP\n</code></pre> <p>The request should succeed, and return some json.</p> <p>Note the headers in the HTTP response.</p> </li> <li> <p>Review the following extension policy:</p> <pre><code>---\napiVersion: gateway.envoyproxy.io/v1alpha1\nkind: EnvoyExtensionPolicy\nmetadata:\n  name: wasm-plugin\nspec:\n  targetRefs:\n  - group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: httpbin\n  wasm:\n  - code:\n      type: Image\n      image:\n        url: us-central1-docker.pkg.dev/eitan-tetrate/misc-repo/wasm:v1\n    config:\n      header_1: my first header\n      header_2: \"yet another header..\"\n</code></pre> <p>Apply the policy:</p> <pre><code>kubectl apply -f wasm/extension-policy.yaml\n</code></pre> </li> <li> <p>Repeat the request:</p> <pre><code>curl -v http://httpbin.example.com/json --resolve httpbin.example.com:80:$GATEWAY_IP\n</code></pre> <p>Note the response headers contain extra headers from the configuration of the wasm plugin.</p> </li> </ol>"}]}